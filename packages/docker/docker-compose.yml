# docker-compose.roost.yml — Full self-hosted Roost stack.
#
# Brings up: Roost backend, PostgreSQL, Redis, MinIO, and Nginx.
#
# Quick start (from repo root):
#   cp server/.env.example server/.env && nano server/.env
#   docker compose -f packages/docker/docker-compose.yml up -d
#   docker compose -f packages/docker/docker-compose.yml ps
#
# Upgrade:
#   docker compose -f packages/docker/docker-compose.yml pull
#   docker compose -f packages/docker/docker-compose.yml up -d --remove-orphans

name: roost

networks:
  roost_net:
    driver: bridge

volumes:
  roost_postgres_data:
    driver: local
  roost_redis_data:
    driver: local
  roost_minio_data:
    driver: local
  roost_nginx_certs:
    driver: local

services:
  # ─── PostgreSQL ─────────────────────────────────────────────────────────────
  postgres:
    image: postgres:16-alpine
    container_name: roost_postgres
    restart: unless-stopped
    networks:
      - roost_net
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-roost}
      POSTGRES_USER: ${POSTGRES_USER:-roost}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    volumes:
      - roost_postgres_data:/var/lib/postgresql/data
    # SECURITY: Postgres is NOT exposed to the host — only Roost can reach it.
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-roost} -d ${POSTGRES_DB:-roost}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

  # ─── Redis ──────────────────────────────────────────────────────────────────
  redis:
    image: redis:7-alpine
    container_name: roost_redis
    restart: unless-stopped
    networks:
      - roost_net
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD:?REDIS_PASSWORD is required}
      --save 60 1
      --loglevel warning
    volumes:
      - roost_redis_data:/data
    # SECURITY: Redis is NOT exposed to the host.
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ─── MinIO (object storage) ─────────────────────────────────────────────────
  # Stores DVR segments, HLS chunks, and cached media.
  # For production at scale, replace with Cloudflare R2 (zero egress cost).
  minio:
    image: minio/minio:latest
    container_name: roost_minio
    restart: unless-stopped
    networks:
      - roost_net
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-roost}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:?MINIO_ROOT_PASSWORD is required}
    volumes:
      - roost_minio_data:/data
    command: server /data --console-address ":9001"
    # SECURITY: MinIO ports are NOT exposed. Roost accesses it via internal network.
    # To access the MinIO console during debugging, add to docker-compose.override.yml:
    #   ports:
    #     - "127.0.0.1:9001:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

  # ─── Roost backend ──────────────────────────────────────────────────────────
  roost:
    image: ghcr.io/unyeco/roost:latest
    container_name: roost_app
    restart: unless-stopped
    networks:
      - roost_net
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    environment:
      # Core
      ROOST_MODE: ${ROOST_MODE:-private}
      ROOST_SECRET_KEY: ${ROOST_SECRET_KEY:?ROOST_SECRET_KEY is required}
      ROOST_DOMAIN: ${ROOST_DOMAIN:-localhost}
      PORT: ${ROOST_PORT:-8080}
      # Database
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB:-roost}
      POSTGRES_USER: ${POSTGRES_USER:-roost}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      # Redis
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
      # MinIO / object storage
      STORAGE_ENDPOINT: http://minio:9000
      STORAGE_ACCESS_KEY: ${MINIO_ROOT_USER:-roost}
      STORAGE_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      STORAGE_BUCKET: ${MINIO_BUCKET:-roost-media}
      # Media paths (mounted from host)
      MEDIA_PATH: /media
      RECORDINGS_PATH: /recordings
      # Public mode (only required when ROOST_MODE=public)
      STRIPE_SECRET_KEY: ${STRIPE_SECRET_KEY:-}
      STRIPE_WEBHOOK_SECRET: ${STRIPE_WEBHOOK_SECRET:-}
      CDN_RELAY_URL: ${CDN_RELAY_URL:-}
      CDN_HMAC_SECRET: ${CDN_HMAC_SECRET:-}
    volumes:
      # Media library — read-only so Roost cannot modify your media
      - ${ROOST_MEDIA_PATH:-./media}:/media:ro
      # DVR recordings — read-write so Roost can write recorded content
      - ${ROOST_RECORDINGS_PATH:-./recordings}:/recordings:rw
    # SECURITY: Roost port is NOT exposed directly — traffic goes through Nginx.
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:${ROOST_PORT:-8080}/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # ─── Nginx reverse proxy ────────────────────────────────────────────────────
  # Handles HTTP→HTTPS redirect, SSL termination, and proxying to Roost.
  # Ports 80 and 443 are the only ports exposed to the host.
  nginx:
    image: nginx:1.27-alpine
    container_name: roost_nginx
    restart: unless-stopped
    networks:
      - roost_net
    depends_on:
      roost:
        condition: service_healthy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./packages/docker/nginx.conf:/etc/nginx/conf.d/roost.conf:ro
      - roost_nginx_certs:/etc/letsencrypt:ro
      # Certbot webroot for ACME challenge
      - ./certbot/www:/var/www/certbot:ro
    healthcheck:
      test: ["CMD-SHELL", "nginx -t && wget -qO- http://localhost/health 2>/dev/null | grep -q ok || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ─── Certbot (Let's Encrypt) ─────────────────────────────────────────────────
  # Uncomment this service to enable automatic HTTPS.
  # Run once manually to issue the first certificate:
  #   docker compose -f docker-compose.roost.yml run --rm certbot certonly \
  #     --webroot -w /var/www/certbot \
  #     -d ${ROOST_DOMAIN} \
  #     --email ${ACME_EMAIL} \
  #     --agree-tos --no-eff-email
  #
  # Then uncomment below and restart. Certbot renews certificates automatically.
  #
  # certbot:
  #   image: certbot/certbot:latest
  #   container_name: roost_certbot
  #   volumes:
  #     - roost_nginx_certs:/etc/letsencrypt
  #     - ./certbot/www:/var/www/certbot
  #   entrypoint: /bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done'
